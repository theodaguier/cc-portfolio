import "./chunk-DSTXS4JB.js";

// node_modules/gsap-trial/ScrollTrigger.js
var e;
var t;
var r;
var i;
var o;
var s;
var n;
var a;
var l;
var c;
var d;
var p;
var h;
var g;
var u = () => e || "undefined" != typeof window && (e = window.gsap) && e.registerPlugin && e;
var f = 1;
var m = [];
var v = [];
var y = [];
var x = Date.now;
var b = (e2, t2) => t2;
var w = (e2, t2) => ~y.indexOf(e2) && y[y.indexOf(e2) + 1][t2];
var _ = (e2) => !!~d.indexOf(e2);
var S = (e2, t2, r2, i2, o2) => e2.addEventListener(t2, r2, { passive: !i2, capture: !!o2 });
var T = (e2, t2, r2, i2) => e2.removeEventListener(t2, r2, !!i2);
var k = () => p && p.isPressed || v.cache++;
var E = (e2, t2) => {
  let r2 = (o2) => {
    if (o2 || 0 === o2) {
      f && (i.history.scrollRestoration = "manual");
      let t3 = p && p.isPressed;
      o2 = r2.v = Math.round(o2) || (p && p.iOS ? 1 : 0), e2(o2), r2.cacheID = v.cache, t3 && b("ss", o2);
    } else
      (t2 || v.cache !== r2.cacheID || b("ref")) && (r2.cacheID = v.cache, r2.v = e2());
    return r2.v + r2.offset;
  };
  return r2.offset = 0, e2 && r2;
};
var P = { s: "scrollLeft", p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: E(function(e2) {
  return arguments.length ? i.scrollTo(e2, M.sc()) : i.pageXOffset || o.scrollLeft || s.scrollLeft || n.scrollLeft || 0;
}) };
var M = { s: "scrollTop", p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: P, sc: E(function(e2) {
  return arguments.length ? i.scrollTo(P.sc(), e2) : i.pageYOffset || o.scrollTop || s.scrollTop || n.scrollTop || 0;
}) };
var C = (t2) => e.utils.toArray(t2)[0] || ("string" == typeof t2 && false !== e.config().nullTargetWarn ? console.warn("Element not found:", t2) : null);
var O = (t2, { s: r2, sc: i2 }) => {
  _(t2) && (t2 = o.scrollingElement || s);
  let n2 = v.indexOf(t2), a2 = i2 === M.sc ? 1 : 2;
  !~n2 && (n2 = v.push(t2) - 1), v[n2 + a2] || t2.addEventListener("scroll", k);
  let l2 = v[n2 + a2], c2 = l2 || (v[n2 + a2] = E(w(t2, r2), true) || (_(t2) ? i2 : E(function(e2) {
    return arguments.length ? t2[r2] = e2 : t2[r2];
  })));
  return c2.target = t2, l2 || (c2.smooth = "smooth" === e.getProperty(t2, "scrollBehavior")), c2;
};
var A = (e2, t2, r2) => {
  let i2 = e2, o2 = e2, s2 = x(), n2 = s2, a2 = t2 || 50, l2 = Math.max(500, 3 * a2), c2 = (e3, t3) => {
    let l3 = x();
    t3 || l3 - s2 > a2 ? (o2 = i2, i2 = e3, n2 = s2, s2 = l3) : r2 ? i2 += e3 : i2 = o2 + (e3 - o2) / (l3 - n2) * (s2 - n2);
  };
  return { update: c2, reset: () => {
    o2 = i2 = r2 ? 0 : i2, n2 = s2 = 0;
  }, getVelocity: (e3) => {
    let t3 = n2, a3 = o2, d2 = x();
    return (e3 || 0 === e3) && e3 !== i2 && c2(e3), s2 === n2 || d2 - n2 > l2 ? 0 : (i2 + (r2 ? a3 : -a3)) / ((r2 ? d2 : s2) - t3) * 1e3;
  } };
};
var R = (e2, t2) => (t2 && !e2._gsapAllow && e2.preventDefault(), e2.changedTouches ? e2.changedTouches[0] : e2);
var D = (e2) => {
  let t2 = Math.max(...e2), r2 = Math.min(...e2);
  return Math.abs(t2) >= Math.abs(r2) ? t2 : r2;
};
var Y = () => {
  c = e.core.globals().ScrollTrigger, c && c.core && (() => {
    let e2 = c.core, t2 = e2.bridge || {}, r2 = e2._scrollers, i2 = e2._proxies;
    r2.push(...v), i2.push(...y), v = r2, y = i2, b = (e3, r3) => t2[e3](r3);
  })();
};
var I = (c2) => (e = c2 || u(), e && "undefined" != typeof document && document.body && (i = window, o = document, s = o.documentElement, n = o.body, d = [i, o, s, n], r = e.utils.clamp, g = e.core.context || function() {
}, l = "onpointerenter" in n ? "pointer" : "mouse", a = L.isTouch = i.matchMedia && i.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in i || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, h = L.eventTypes = ("ontouchstart" in s ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in s ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(() => f = 0, 500), Y(), t = 1), t);
P.op = M, v.cache = 0;
var L = class {
  constructor(e2) {
    this.init(e2);
  }
  init(r2) {
    t || I(e) || console.warn("Please gsap.registerPlugin(Observer)"), c || Y();
    let { tolerance: d2, dragMinimum: u2, type: f2, target: v2, lineHeight: y2, debounce: b2, preventDefault: w2, onStop: E2, onStopDelay: L2, ignore: X2, wheelSpeed: B2, event: z2, onDragStart: W2, onDragEnd: F2, onDrag: N2, onPress: H2, onRelease: q2, onRight: V2, onLeft: U2, onUp: G2, onDown: j2, onChangeX: K2, onChangeY: Z2, onChange: $2, onToggleX: J2, onToggleY: Q2, onHover: ee2, onHoverEnd: te2, onMove: re2, ignoreCheck: ie2, isNormalizer: oe2, onGestureStart: se2, onGestureEnd: ne2, onWheel: ae2, onEnable: le2, onDisable: ce2, onClick: de2, scrollSpeed: pe2, capture: he2, allowClicks: ge2, lockAxis: ue2, onLockAxis: fe2 } = r2;
    this.target = v2 = C(v2) || s, this.vars = r2, X2 && (X2 = e.utils.toArray(X2)), d2 = d2 || 1e-9, u2 = u2 || 0, B2 = B2 || 1, pe2 = pe2 || 1, f2 = f2 || "wheel,touch,pointer", b2 = false !== b2, y2 || (y2 = parseFloat(i.getComputedStyle(n).lineHeight) || 22);
    let me2, ve2, ye2, xe2, be2, we2, _e2, Se2 = this, Te2 = 0, ke2 = 0, Ee2 = O(v2, P), Pe2 = O(v2, M), Me2 = Ee2(), Ce2 = Pe2(), Oe2 = ~f2.indexOf("touch") && !~f2.indexOf("pointer") && "pointerdown" === h[0], Ae2 = _(v2), Re2 = v2.ownerDocument || o, De2 = [0, 0, 0], Ye2 = [0, 0, 0], Ie2 = 0, Le2 = () => Ie2 = x(), Xe2 = (e2, t2) => (Se2.event = e2) && X2 && ~X2.indexOf(e2.target) || t2 && Oe2 && "touch" !== e2.pointerType || ie2 && ie2(e2, t2), Be2 = () => {
      let e2 = Se2.deltaX = D(De2), t2 = Se2.deltaY = D(Ye2), r3 = Math.abs(e2) >= d2, i2 = Math.abs(t2) >= d2;
      $2 && (r3 || i2) && $2(Se2, e2, t2, De2, Ye2), r3 && (V2 && Se2.deltaX > 0 && V2(Se2), U2 && Se2.deltaX < 0 && U2(Se2), K2 && K2(Se2), J2 && Se2.deltaX < 0 != Te2 < 0 && J2(Se2), Te2 = Se2.deltaX, De2[0] = De2[1] = De2[2] = 0), i2 && (j2 && Se2.deltaY > 0 && j2(Se2), G2 && Se2.deltaY < 0 && G2(Se2), Z2 && Z2(Se2), Q2 && Se2.deltaY < 0 != ke2 < 0 && Q2(Se2), ke2 = Se2.deltaY, Ye2[0] = Ye2[1] = Ye2[2] = 0), (xe2 || ye2) && (re2 && re2(Se2), ye2 && (N2(Se2), ye2 = false), xe2 = false), we2 && !(we2 = false) && fe2 && fe2(Se2), be2 && (ae2(Se2), be2 = false), me2 = 0;
    }, ze2 = (e2, t2, r3) => {
      De2[r3] += e2, Ye2[r3] += t2, Se2._vx.update(e2), Se2._vy.update(t2), b2 ? me2 || (me2 = requestAnimationFrame(Be2)) : Be2();
    }, We2 = (e2, t2) => {
      ue2 && !_e2 && (Se2.axis = _e2 = Math.abs(e2) > Math.abs(t2) ? "x" : "y", we2 = true), "y" !== _e2 && (De2[2] += e2, Se2._vx.update(e2, true)), "x" !== _e2 && (Ye2[2] += t2, Se2._vy.update(t2, true)), b2 ? me2 || (me2 = requestAnimationFrame(Be2)) : Be2();
    }, Fe2 = (e2) => {
      if (Xe2(e2, 1))
        return;
      let t2 = (e2 = R(e2, w2)).clientX, r3 = e2.clientY, i2 = t2 - Se2.x, o2 = r3 - Se2.y, s2 = Se2.isDragging;
      Se2.x = t2, Se2.y = r3, (s2 || Math.abs(Se2.startX - t2) >= u2 || Math.abs(Se2.startY - r3) >= u2) && (N2 && (ye2 = true), s2 || (Se2.isDragging = true), We2(i2, o2), s2 || W2 && W2(Se2));
    }, Ne2 = Se2.onPress = (e2) => {
      Xe2(e2, 1) || (Se2.axis = _e2 = null, ve2.pause(), Se2.isPressed = true, e2 = R(e2), Te2 = ke2 = 0, Se2.startX = Se2.x = e2.clientX, Se2.startY = Se2.y = e2.clientY, Se2._vx.reset(), Se2._vy.reset(), S(oe2 ? v2 : Re2, h[1], Fe2, w2, true), Se2.deltaX = Se2.deltaY = 0, H2 && H2(Se2));
    }, He2 = (t2) => {
      if (Xe2(t2, 1))
        return;
      T(oe2 ? v2 : Re2, h[1], Fe2, true);
      let r3 = !isNaN(Se2.y - Se2.startY), o2 = Se2.isDragging && (Math.abs(Se2.x - Se2.startX) > 3 || Math.abs(Se2.y - Se2.startY) > 3), s2 = R(t2);
      !o2 && r3 && (Se2._vx.reset(), Se2._vy.reset(), w2 && ge2 && e.delayedCall(0.08, () => {
        if (x() - Ie2 > 300 && !t2.defaultPrevented) {
          if (t2.target.click)
            t2.target.click();
          else if (Re2.createEvent) {
            let e2 = Re2.createEvent("MouseEvents");
            e2.initMouseEvent("click", true, true, i, 1, s2.screenX, s2.screenY, s2.clientX, s2.clientY, false, false, false, false, 0, null), t2.target.dispatchEvent(e2);
          }
        }
      })), Se2.isDragging = Se2.isGesturing = Se2.isPressed = false, E2 && !oe2 && ve2.restart(true), F2 && o2 && F2(Se2), q2 && q2(Se2, o2);
    }, qe2 = (e2) => e2.touches && e2.touches.length > 1 && (Se2.isGesturing = true) && se2(e2, Se2.isDragging), Ve2 = () => (Se2.isGesturing = false) || ne2(Se2), Ue2 = (e2) => {
      if (Xe2(e2))
        return;
      let t2 = Ee2(), r3 = Pe2();
      ze2((t2 - Me2) * pe2, (r3 - Ce2) * pe2, 1), Me2 = t2, Ce2 = r3, E2 && ve2.restart(true);
    }, Ge2 = (e2) => {
      if (Xe2(e2))
        return;
      e2 = R(e2, w2), ae2 && (be2 = true);
      let t2 = (1 === e2.deltaMode ? y2 : 2 === e2.deltaMode ? i.innerHeight : 1) * B2;
      ze2(e2.deltaX * t2, e2.deltaY * t2, 0), E2 && !oe2 && ve2.restart(true);
    }, je2 = (e2) => {
      if (Xe2(e2))
        return;
      let t2 = e2.clientX, r3 = e2.clientY, i2 = t2 - Se2.x, o2 = r3 - Se2.y;
      Se2.x = t2, Se2.y = r3, xe2 = true, (i2 || o2) && We2(i2, o2);
    }, Ke2 = (e2) => {
      Se2.event = e2, ee2(Se2);
    }, Ze2 = (e2) => {
      Se2.event = e2, te2(Se2);
    }, $e2 = (e2) => Xe2(e2) || R(e2, w2) && de2(Se2);
    ve2 = Se2._dc = e.delayedCall(L2 || 0.25, () => {
      Se2._vx.reset(), Se2._vy.reset(), ve2.pause(), E2 && E2(Se2);
    }).pause(), Se2.deltaX = Se2.deltaY = 0, Se2._vx = A(0, 50, true), Se2._vy = A(0, 50, true), Se2.scrollX = Ee2, Se2.scrollY = Pe2, Se2.isDragging = Se2.isGesturing = Se2.isPressed = false, g(this), Se2.enable = (e2) => (Se2.isEnabled || (S(Ae2 ? Re2 : v2, "scroll", k), f2.indexOf("scroll") >= 0 && S(Ae2 ? Re2 : v2, "scroll", Ue2, w2, he2), f2.indexOf("wheel") >= 0 && S(v2, "wheel", Ge2, w2, he2), (f2.indexOf("touch") >= 0 && a || f2.indexOf("pointer") >= 0) && (S(v2, h[0], Ne2, w2, he2), S(Re2, h[2], He2), S(Re2, h[3], He2), ge2 && S(v2, "click", Le2, false, true), de2 && S(v2, "click", $e2), se2 && S(Re2, "gesturestart", qe2), ne2 && S(Re2, "gestureend", Ve2), ee2 && S(v2, l + "enter", Ke2), te2 && S(v2, l + "leave", Ze2), re2 && S(v2, l + "move", je2)), Se2.isEnabled = true, e2 && e2.type && Ne2(e2), le2 && le2(Se2)), Se2), Se2.disable = () => {
      Se2.isEnabled && (m.filter((e2) => e2 !== Se2 && _(e2.target)).length || T(Ae2 ? Re2 : v2, "scroll", k), Se2.isPressed && (Se2._vx.reset(), Se2._vy.reset(), T(oe2 ? v2 : Re2, h[1], Fe2, true)), T(Ae2 ? Re2 : v2, "scroll", Ue2, he2), T(v2, "wheel", Ge2, he2), T(v2, h[0], Ne2, he2), T(Re2, h[2], He2), T(Re2, h[3], He2), T(v2, "click", Le2, true), T(v2, "click", $e2), T(Re2, "gesturestart", qe2), T(Re2, "gestureend", Ve2), T(v2, l + "enter", Ke2), T(v2, l + "leave", Ze2), T(v2, l + "move", je2), Se2.isEnabled = Se2.isPressed = Se2.isDragging = false, ce2 && ce2(Se2));
    }, Se2.kill = Se2.revert = () => {
      Se2.disable();
      let e2 = m.indexOf(Se2);
      e2 >= 0 && m.splice(e2, 1), p === Se2 && (p = 0);
    }, m.push(Se2), oe2 && _(v2) && (p = Se2), Se2.enable(z2);
  }
  get velocityX() {
    return this._vx.getVelocity();
  }
  get velocityY() {
    return this._vy.getVelocity();
  }
};
L.version = "3.11.4", L.create = (e2) => new L(e2), L.register = I, L.getAll = () => m.slice(), L.getById = (e2) => m.filter((t2) => t2.vars.id === e2)[0], u() && e.registerPlugin(L);
var X;
var B;
var z;
var W;
var F;
var N;
var H;
var q;
var V;
var U;
var G;
var j;
var K;
var Z;
var $;
var J;
var Q;
var ee;
var te;
var re;
var ie;
var oe;
var se;
var ne;
var ae;
var le;
var ce;
var de;
var pe;
var he;
var ge;
var ue;
var fe;
var me;
var ve = 1;
var ye = Date.now;
var xe = ye();
var be = 0;
var we = 0;
var _e = () => Z = 1;
var Se = () => Z = 0;
var Te = (e2) => e2;
var ke = (e2) => Math.round(1e5 * e2) / 1e5 || 0;
var Ee = () => "undefined" != typeof window;
var Pe = () => X || Ee() && (X = window.gsap) && X.registerPlugin && X;
var Me = (e2) => !!~H.indexOf(e2);
var Ce = (e2) => w(e2, "getBoundingClientRect") || (Me(e2) ? () => (Mt.width = z.innerWidth, Mt.height = z.innerHeight, Mt) : () => He(e2));
var Oe = (e2, { s: t2, d2: r2, d: i2, a: o2 }) => (t2 = "scroll" + r2) && (o2 = w(e2, t2)) ? o2() - Ce(e2)()[i2] : Me(e2) ? (F[t2] || N[t2]) - (z["inner" + r2] || F["client" + r2] || N["client" + r2]) : e2[t2] - e2["offset" + r2];
var Ae = (e2, t2) => {
  for (let r2 = 0; r2 < te.length; r2 += 3)
    (!t2 || ~t2.indexOf(te[r2 + 1])) && e2(te[r2], te[r2 + 1], te[r2 + 2]);
};
var Re = (e2) => "string" == typeof e2;
var De = (e2) => "function" == typeof e2;
var Ye = (e2) => "number" == typeof e2;
var Ie = (e2) => "object" == typeof e2;
var Le = (e2, t2, r2) => e2 && e2.progress(t2 ? 0 : 1) && r2 && e2.pause();
var Xe = (e2, t2) => {
  if (e2.enabled) {
    let r2 = t2(e2);
    r2 && r2.totalTime && (e2.callbackAnimation = r2);
  }
};
var Be = Math.abs;
var ze = "padding";
var We = "px";
var Fe = (e2) => z.getComputedStyle(e2);
var Ne = (e2, t2) => {
  for (let r2 in t2)
    r2 in e2 || (e2[r2] = t2[r2]);
  return e2;
};
var He = (e2, t2) => {
  let r2 = t2 && "matrix(1, 0, 0, 1, 0, 0)" !== Fe(e2)[$] && X.to(e2, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), i2 = e2.getBoundingClientRect();
  return r2 && r2.progress(0).kill(), i2;
};
var qe = (e2, { d2: t2 }) => e2["offset" + t2] || e2["client" + t2] || 0;
var Ve = (e2) => {
  let t2, r2 = [], i2 = e2.labels, o2 = e2.duration();
  for (t2 in i2)
    r2.push(i2[t2] / o2);
  return r2;
};
var Ue = (e2) => {
  let t2 = X.utils.snap(e2), r2 = Array.isArray(e2) && e2.slice(0).sort((e3, t3) => e3 - t3);
  return r2 ? (e3, i2, o2 = 1e-3) => {
    let s2;
    if (!i2)
      return t2(e3);
    if (i2 > 0) {
      for (e3 -= o2, s2 = 0; s2 < r2.length; s2++)
        if (r2[s2] >= e3)
          return r2[s2];
      return r2[s2 - 1];
    }
    for (s2 = r2.length, e3 += o2; s2--; )
      if (r2[s2] <= e3)
        return r2[s2];
    return r2[0];
  } : (r3, i2, o2 = 1e-3) => {
    let s2 = t2(r3);
    return !i2 || Math.abs(s2 - r3) < o2 || s2 - r3 < 0 == i2 < 0 ? s2 : t2(i2 < 0 ? r3 - e2 : r3 + e2);
  };
};
var Ge = (e2, t2, r2, i2) => r2.split(",").forEach((r3) => e2(t2, r3, i2));
var je = (e2, t2, r2, i2, o2) => e2.addEventListener(t2, r2, { passive: !i2, capture: !!o2 });
var Ke = (e2, t2, r2, i2) => e2.removeEventListener(t2, r2, !!i2);
var Ze = (e2, t2, r2) => r2 && r2.wheelHandler && e2(t2, "wheel", r2);
var $e = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" };
var Je = { toggleActions: "play", anticipatePin: 0 };
var Qe = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 };
var et = (e2, t2) => {
  if (Re(e2)) {
    let r2 = e2.indexOf("="), i2 = ~r2 ? +(e2.charAt(r2 - 1) + 1) * parseFloat(e2.substr(r2 + 1)) : 0;
    ~r2 && (e2.indexOf("%") > r2 && (i2 *= t2 / 100), e2 = e2.substr(0, r2 - 1)), e2 = i2 + (e2 in Qe ? Qe[e2] * t2 : ~e2.indexOf("%") ? parseFloat(e2) * t2 / 100 : parseFloat(e2) || 0);
  }
  return e2;
};
var tt = (e2, t2, r2, i2, { startColor: o2, endColor: s2, fontSize: n2, indent: a2, fontWeight: l2 }, c2, d2, p2) => {
  let h2 = W.createElement("div"), g2 = Me(r2) || "fixed" === w(r2, "pinType"), u2 = -1 !== e2.indexOf("scroller"), f2 = g2 ? N : r2, m2 = -1 !== e2.indexOf("start"), v2 = m2 ? o2 : s2, y2 = "border-color:" + v2 + ";font-size:" + n2 + ";color:" + v2 + ";font-weight:" + l2 + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return y2 += "position:" + ((u2 || p2) && g2 ? "fixed;" : "absolute;"), (u2 || p2 || !g2) && (y2 += (i2 === M ? "right" : "bottom") + ":" + (c2 + parseFloat(a2)) + "px;"), d2 && (y2 += "box-sizing:border-box;text-align:left;width:" + d2.offsetWidth + "px;"), h2._isStart = m2, h2.setAttribute("class", "gsap-marker-" + e2 + (t2 ? " marker-" + t2 : "")), h2.style.cssText = y2, h2.innerText = t2 || 0 === t2 ? e2 + "-" + t2 : e2, f2.children[0] ? f2.insertBefore(h2, f2.children[0]) : f2.appendChild(h2), h2._offset = h2["offset" + i2.op.d2], rt(h2, 0, i2, m2), h2;
};
var rt = (e2, t2, r2, i2) => {
  let o2 = { display: "block" }, s2 = r2[i2 ? "os2" : "p2"], n2 = r2[i2 ? "p2" : "os2"];
  e2._isFlipped = i2, o2[r2.a + "Percent"] = i2 ? -100 : 0, o2[r2.a] = i2 ? "1px" : 0, o2["border" + s2 + "Width"] = 1, o2["border" + n2 + "Width"] = 0, o2[r2.p] = t2 + "px", X.set(e2, o2);
};
var it = [];
var ot = {};
var st = () => ye() - be > 34 && (ge || (ge = requestAnimationFrame(wt)));
var nt = () => {
  (!se || !se.isPressed || se.startX > N.clientWidth) && (v.cache++, se ? ge || (ge = requestAnimationFrame(wt)) : wt(), be || ht("scrollStart"), be = ye());
};
var at = () => {
  le = z.innerWidth, ae = z.innerHeight;
};
var lt = () => {
  v.cache++, !K && !oe && !W.fullscreenElement && !W.webkitFullscreenElement && (!ne || le !== z.innerWidth || Math.abs(z.innerHeight - ae) > 0.25 * z.innerHeight) && q.restart(true);
};
var ct = {};
var dt = [];
var pt = () => Ke(Dt, "scrollEnd", pt) || yt(true);
var ht = (e2) => ct[e2] && ct[e2].map((e3) => e3()) || dt;
var gt = [];
var ut = (e2) => {
  for (let t2 = 0; t2 < gt.length; t2 += 5)
    (!e2 || gt[t2 + 4] && gt[t2 + 4].query === e2) && (gt[t2].style.cssText = gt[t2 + 1], gt[t2].getBBox && gt[t2].setAttribute("transform", gt[t2 + 2] || ""), gt[t2 + 3].uncache = 1);
};
var ft = (e2, t2) => {
  let r2;
  for (J = 0; J < it.length; J++)
    r2 = it[J], !r2 || t2 && r2._ctx !== t2 || (e2 ? r2.kill(1) : r2.revert(true, true));
  t2 && ut(t2), t2 || ht("revert");
};
var mt = (e2, t2) => {
  v.cache++, (t2 || !ue) && v.forEach((e3) => De(e3) && e3.cacheID++ && (e3.rec = 0)), Re(e2) && (z.history.scrollRestoration = pe = e2);
};
var vt = 0;
var yt = (e2, t2) => {
  if (be && !e2)
    return void je(Dt, "scrollEnd", pt);
  ue = Dt.isRefreshing = true, v.forEach((e3) => De(e3) && e3.cacheID++ && (e3.rec = e3()));
  let r2 = ht("refreshInit");
  re && Dt.sort(), t2 || ft(), v.forEach((e3) => {
    De(e3) && (e3.smooth && (e3.target.style.scrollBehavior = "auto"), e3(0));
  }), it.slice(0).forEach((e3) => e3.refresh()), it.forEach((e3, t3) => {
    if (e3._subPinOffset && e3.pin) {
      let t4 = e3.vars.horizontal ? "offsetWidth" : "offsetHeight", r3 = e3.pin[t4];
      e3.revert(true, 1), e3.adjustPinSpacing(e3.pin[t4] - r3), e3.revert(false, 1);
    }
  }), it.forEach((e3) => "max" === e3.vars.end && e3.setPositions(e3.start, Math.max(e3.start + 1, Oe(e3.scroller, e3._dir)))), r2.forEach((e3) => e3 && e3.render && e3.render(-1)), v.forEach((e3) => {
    De(e3) && (e3.smooth && requestAnimationFrame(() => e3.target.style.scrollBehavior = "smooth"), e3.rec && e3(e3.rec));
  }), mt(pe, 1), q.pause(), vt++, wt(2), it.forEach((e3) => De(e3.vars.onRefresh) && e3.vars.onRefresh(e3)), ue = Dt.isRefreshing = false, ht("refresh");
};
var xt = 0;
var bt = 1;
var wt = (e2) => {
  if (!ue || 2 === e2) {
    Dt.isUpdating = true, me && me.update(0);
    let e3 = it.length, t2 = ye(), r2 = t2 - xe >= 50, i2 = e3 && it[0].scroll();
    if (bt = xt > i2 ? -1 : 1, xt = i2, r2 && (be && !Z && t2 - be > 200 && (be = 0, ht("scrollEnd")), G = xe, xe = t2), bt < 0) {
      for (J = e3; J-- > 0; )
        it[J] && it[J].update(0, r2);
      bt = 1;
    } else
      for (J = 0; J < e3; J++)
        it[J] && it[J].update(0, r2);
    Dt.isUpdating = false;
  }
  ge = 0;
};
var _t = ["left", "top", "bottom", "right", "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
var St = _t.concat(["width", "height", "boxSizing", "maxWidth", "maxHeight", "position", "margin", ze, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]);
var Tt = (e2, t2, r2, i2) => {
  if (!e2._gsap.swappedIn) {
    let o2, s2 = _t.length, n2 = t2.style, a2 = e2.style;
    for (; s2--; )
      o2 = _t[s2], n2[o2] = r2[o2];
    n2.position = "absolute" === r2.position ? "absolute" : "relative", "inline" === r2.display && (n2.display = "inline-block"), a2.bottom = a2.right = "auto", n2.flexBasis = r2.flexBasis || "auto", n2.overflow = "visible", n2.boxSizing = "border-box", n2.width = qe(e2, P) + We, n2.height = qe(e2, M) + We, n2.padding = a2.margin = a2.top = a2.left = "0", Et(i2), a2.width = a2.maxWidth = r2.width, a2.height = a2.maxHeight = r2.height, a2.padding = r2.padding, e2.parentNode !== t2 && (e2.parentNode.insertBefore(t2, e2), t2.appendChild(e2)), e2._gsap.swappedIn = true;
  }
};
var kt = /([A-Z])/g;
var Et = (e2) => {
  if (e2) {
    let t2, r2, i2 = e2.t.style, o2 = e2.length, s2 = 0;
    for ((e2.t._gsap || X.core.getCache(e2.t)).uncache = 1; s2 < o2; s2 += 2)
      r2 = e2[s2 + 1], t2 = e2[s2], r2 ? i2[t2] = r2 : i2[t2] && i2.removeProperty(t2.replace(kt, "-$1").toLowerCase());
  }
};
var Pt = (e2) => {
  let t2 = St.length, r2 = e2.style, i2 = [], o2 = 0;
  for (; o2 < t2; o2++)
    i2.push(St[o2], r2[St[o2]]);
  return i2.t = e2, i2;
};
var Mt = { left: 0, top: 0 };
var Ct = (e2, t2, r2, i2, o2, s2, n2, a2, l2, c2, d2, p2, h2) => {
  De(e2) && (e2 = e2(a2)), Re(e2) && "max" === e2.substr(0, 3) && (e2 = p2 + ("=" === e2.charAt(4) ? et("0" + e2.substr(3), r2) : 0));
  let g2, u2, f2, m2 = h2 ? h2.time() : 0;
  if (h2 && h2.seek(0), Ye(e2))
    n2 && rt(n2, r2, i2, true);
  else {
    De(t2) && (t2 = t2(a2));
    let s3, d3, p3, h3, g3 = (e2 || "0").split(" ");
    f2 = C(t2) || N, s3 = He(f2) || {}, s3 && (s3.left || s3.top) || "none" !== Fe(f2).display || (h3 = f2.style.display, f2.style.display = "block", s3 = He(f2), h3 ? f2.style.display = h3 : f2.style.removeProperty("display")), d3 = et(g3[0], s3[i2.d]), p3 = et(g3[1] || "0", r2), e2 = s3[i2.p] - l2[i2.p] - c2 + d3 + o2 - p3, n2 && rt(n2, p3, i2, r2 - p3 < 20 || n2._isStart && p3 > 20), r2 -= r2 - p3;
  }
  if (s2) {
    let t3 = e2 + r2, o3 = s2._isStart;
    g2 = "scroll" + i2.d2, rt(s2, t3, i2, o3 && t3 > 20 || !o3 && (d2 ? Math.max(N[g2], F[g2]) : s2.parentNode[g2]) <= t3 + 1), d2 && (l2 = He(n2), d2 && (s2.style[i2.op.p] = l2[i2.op.p] - i2.op.m - s2._offset + We));
  }
  return h2 && f2 && (g2 = He(f2), h2.seek(p2), u2 = He(f2), h2._caScrollDist = g2[i2.p] - u2[i2.p], e2 = e2 / h2._caScrollDist * p2), h2 && h2.seek(m2), h2 ? e2 : Math.round(e2);
};
var Ot = /(webkit|moz|length|cssText|inset)/i;
var At = (e2, t2, r2, i2) => {
  if (e2.parentNode !== t2) {
    let o2, s2, n2 = e2.style;
    if (t2 === N) {
      for (o2 in e2._stOrig = n2.cssText, s2 = Fe(e2), s2)
        +o2 || Ot.test(o2) || !s2[o2] || "string" != typeof n2[o2] || "0" === o2 || (n2[o2] = s2[o2]);
      n2.top = r2, n2.left = i2;
    } else
      n2.cssText = e2._stOrig;
    X.core.getCache(e2).uncache = 1, t2.appendChild(e2);
  }
};
var Rt = (e2, t2) => {
  let r2, i2, o2 = O(e2, t2), s2 = "_scroll" + t2.p2, n2 = (t3, a2, l2, c2, d2) => {
    let p2 = n2.tween, h2 = a2.onComplete, g2 = {};
    return l2 = l2 || o2(), d2 = c2 && d2 || 0, c2 = c2 || t3 - l2, p2 && p2.kill(), r2 = Math.round(l2), a2[s2] = t3, a2.modifiers = g2, g2[s2] = (e3) => ((e3 = Math.round(o2())) !== r2 && e3 !== i2 && Math.abs(e3 - r2) > 3 && Math.abs(e3 - i2) > 3 ? (p2.kill(), n2.tween = 0) : e3 = l2 + c2 * p2.ratio + d2 * p2.ratio * p2.ratio, i2 = r2, r2 = Math.round(e3)), a2.onUpdate = () => {
      v.cache++, wt();
    }, a2.onComplete = () => {
      n2.tween = 0, h2 && h2.call(p2);
    }, p2 = n2.tween = X.to(e2, a2), p2;
  };
  return e2[s2] = o2, o2.wheelHandler = () => n2.tween && n2.tween.kill() && (n2.tween = 0), je(e2, "wheel", o2.wheelHandler), n2;
};
var Dt = class {
  constructor(e2, t2) {
    B || Dt.register(X) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(e2, t2);
  }
  init(e2, t2) {
    if (this.progress = this.start = 0, this.vars && this.kill(true, true), !we)
      return void (this.update = this.refresh = this.kill = Te);
    e2 = Ne(Re(e2) || Ye(e2) || e2.nodeType ? { trigger: e2 } : e2, Je);
    let r2, i2, o2, s2, n2, a2, l2, c2, d2, p2, h2, g2, u2, f2, m2, x2, b2, _2, S2, T2, k2, E2, A2, R2, D2, Y2, I2, L2, B2, H2, q2, j2, $2, Q2, ee2, te2, oe2, se2, ne2, { onUpdate: ae2, toggleClass: le2, id: ce2, onToggle: pe2, onRefresh: ge2, scrub: xe2, trigger: _e2, pin: Se2, pinSpacing: Ee2, invalidateOnRefresh: Pe2, anticipatePin: Ae2, onScrubComplete: Ge2, onSnapComplete: Ze2, once: Qe2, snap: rt2, pinReparent: st2, pinSpacer: at2, containerAnimation: ct2, fastScrollEnd: dt2, preventOverlaps: ht2 } = e2, gt2 = e2.horizontal || e2.containerAnimation && false !== e2.horizontal ? P : M, ut2 = !xe2 && 0 !== xe2, ft2 = C(e2.scroller || z), mt2 = X.core.getCache(ft2), xt2 = Me(ft2), wt2 = "fixed" === ("pinType" in e2 ? e2.pinType : w(ft2, "pinType") || xt2 && "fixed"), _t2 = [e2.onEnter, e2.onLeave, e2.onEnterBack, e2.onLeaveBack], St2 = ut2 && e2.toggleActions.split(" "), kt2 = "markers" in e2 ? e2.markers : Je.markers, Ot2 = xt2 ? 0 : parseFloat(Fe(ft2)["border" + gt2.p2 + "Width"]) || 0, Yt2 = this, It2 = e2.onRefreshInit && (() => e2.onRefreshInit(Yt2)), Lt2 = ((e3, t3, { d: r3, d2: i3, a: o3 }) => (o3 = w(e3, "getBoundingClientRect")) ? () => o3()[r3] : () => (t3 ? z["inner" + i3] : e3["client" + i3]) || 0)(ft2, xt2, gt2), Xt2 = ((e3, t3) => !t3 || ~y.indexOf(e3) ? Ce(e3) : () => Mt)(ft2, xt2), Bt2 = 0, zt2 = 0, Wt2 = O(ft2, gt2);
    var Ft2;
    if (de(Yt2), Yt2._dir = gt2, Ae2 *= 45, Yt2.scroller = ft2, Yt2.scroll = ct2 ? ct2.time.bind(ct2) : Wt2, s2 = Wt2(), Yt2.vars = e2, t2 = t2 || e2.animation, "refreshPriority" in e2 && (re = 1, -9999 === e2.refreshPriority && (me = Yt2)), mt2.tweenScroll = mt2.tweenScroll || { top: Rt(ft2, M), left: Rt(ft2, P) }, Yt2.tweenTo = r2 = mt2.tweenScroll[gt2.p], Yt2.scrubDuration = (e3) => {
      j2 = Ye(e3) && e3, j2 ? q2 ? q2.duration(e3) : q2 = X.to(t2, { ease: "expo", totalProgress: "+=0.001", duration: j2, paused: true, onComplete: () => Ge2 && Ge2(Yt2) }) : (q2 && q2.progress(1).kill(), q2 = 0);
    }, t2 && (t2.vars.lazy = false, t2._initted || false !== t2.vars.immediateRender && false !== e2.immediateRender && t2.duration() && t2.render(0, true, true), Yt2.animation = t2.pause(), t2.scrollTrigger = Yt2, Yt2.scrubDuration(xe2), B2 = 0, ce2 || (ce2 = t2.vars.id)), it.push(Yt2), rt2 && (Ie(rt2) && !rt2.push || (rt2 = { snapTo: rt2 }), "scrollBehavior" in N.style && X.set(xt2 ? [N, F] : ft2, { scrollBehavior: "auto" }), v.forEach((e3) => De(e3) && e3.target === (xt2 ? W.scrollingElement || F : ft2) && (e3.smooth = false)), o2 = De(rt2.snapTo) ? rt2.snapTo : "labels" === rt2.snapTo ? ((e3) => (t3) => X.utils.snap(Ve(e3), t3))(t2) : "labelsDirectional" === rt2.snapTo ? (Ft2 = t2, (e3, t3) => Ue(Ve(Ft2))(e3, t3.direction)) : false !== rt2.directional ? (e3, t3) => Ue(rt2.snapTo)(e3, ye() - zt2 < 500 ? 0 : t3.direction) : X.utils.snap(rt2.snapTo), $2 = rt2.duration || { min: 0.1, max: 2 }, $2 = Ie($2) ? U($2.min, $2.max) : U($2, $2), Q2 = X.delayedCall(rt2.delay || j2 / 2 || 0.1, () => {
      let e3 = Wt2(), i3 = ye() - zt2 < 500, s3 = r2.tween;
      if (!(i3 || Math.abs(Yt2.getVelocity()) < 10) || s3 || Z || Bt2 === e3)
        Yt2.isActive && Bt2 !== e3 && Q2.restart(true);
      else {
        let n3 = (e3 - a2) / u2, c3 = t2 && !ut2 ? t2.totalProgress() : n3, d3 = i3 ? 0 : (c3 - H2) / (ye() - G) * 1e3 || 0, p3 = X.utils.clamp(-n3, 1 - n3, Be(d3 / 2) * d3 / 0.185), h3 = n3 + (false === rt2.inertia ? 0 : p3), g3 = U(0, 1, o2(h3, Yt2)), f3 = Math.round(a2 + g3 * u2), { onStart: m3, onInterrupt: v2, onComplete: y2 } = rt2;
        if (e3 <= l2 && e3 >= a2 && f3 !== e3) {
          if (s3 && !s3._initted && s3.data <= Be(f3 - e3))
            return;
          false === rt2.inertia && (p3 = g3 - n3), r2(f3, { duration: $2(Be(0.185 * Math.max(Be(h3 - c3), Be(g3 - c3)) / d3 / 0.05 || 0)), ease: rt2.ease || "power3", data: Be(f3 - e3), onInterrupt: () => Q2.restart(true) && v2 && v2(Yt2), onComplete: () => {
            Yt2.update(), Bt2 = Wt2(), B2 = H2 = t2 && !ut2 ? t2.totalProgress() : Yt2.progress, Ze2 && Ze2(Yt2), y2 && y2(Yt2);
          } }, e3, p3 * u2, f3 - e3 - p3 * u2), m3 && m3(Yt2, r2.tween);
        }
      }
    }).pause()), ce2 && (ot[ce2] = Yt2), _e2 = Yt2.trigger = C(_e2 || Se2), ne2 = _e2 && _e2._gsap && _e2._gsap.stRevert, ne2 && (ne2 = ne2(Yt2)), Se2 = true === Se2 ? _e2 : C(Se2), Re(le2) && (le2 = { targets: _e2, className: le2 }), Se2 && (false === Ee2 || "margin" === Ee2 || (Ee2 = !(!Ee2 && Se2.parentNode && Se2.parentNode.style && "flex" === Fe(Se2.parentNode).display) && ze), Yt2.pin = Se2, i2 = X.core.getCache(Se2), i2.spacer ? f2 = i2.pinState : (at2 && (at2 = C(at2), at2 && !at2.nodeType && (at2 = at2.current || at2.nativeElement), i2.spacerIsNative = !!at2, at2 && (i2.spacerState = Pt(at2))), i2.spacer = b2 = at2 || W.createElement("div"), b2.classList.add("pin-spacer"), ce2 && b2.classList.add("pin-spacer-" + ce2), i2.pinState = f2 = Pt(Se2)), false !== e2.force3D && X.set(Se2, { force3D: true }), Yt2.spacer = b2 = i2.spacer, L2 = Fe(Se2), A2 = L2[Ee2 + gt2.os2], S2 = X.getProperty(Se2), T2 = X.quickSetter(Se2, gt2.a, We), Tt(Se2, b2, L2), x2 = Pt(Se2)), kt2) {
      g2 = Ie(kt2) ? Ne(kt2, $e) : $e, p2 = tt("scroller-start", ce2, ft2, gt2, g2, 0), h2 = tt("scroller-end", ce2, ft2, gt2, g2, 0, p2), _2 = p2["offset" + gt2.op.d2];
      let e3 = C(w(ft2, "content") || ft2);
      c2 = this.markerStart = tt("start", ce2, e3, gt2, g2, _2, 0, ct2), d2 = this.markerEnd = tt("end", ce2, e3, gt2, g2, _2, 0, ct2), ct2 && (se2 = X.quickSetter([c2, d2], gt2.a, We)), wt2 || y.length && true === w(ft2, "fixedMarkers") || (((e4) => {
        let t3 = Fe(e4).position;
        e4.style.position = "absolute" === t3 || "fixed" === t3 ? t3 : "relative";
      })(xt2 ? N : ft2), X.set([p2, h2], { force3D: true }), D2 = X.quickSetter(p2, gt2.a, We), I2 = X.quickSetter(h2, gt2.a, We));
    }
    if (ct2) {
      let e3 = ct2.vars.onUpdate, t3 = ct2.vars.onUpdateParams;
      ct2.eventCallback("onUpdate", () => {
        Yt2.update(0, 0, 1), e3 && e3.apply(t3 || []);
      });
    }
    Yt2.previous = () => it[it.indexOf(Yt2) - 1], Yt2.next = () => it[it.indexOf(Yt2) + 1], Yt2.revert = (e3, r3) => {
      if (!r3)
        return Yt2.kill(true);
      let i3 = false !== e3 || !Yt2.enabled, o3 = K;
      i3 !== Yt2.isReverted && (i3 && (te2 = Math.max(Wt2(), Yt2.scroll.rec || 0), ee2 = Yt2.progress, oe2 = t2 && t2.progress()), c2 && [c2, d2, p2, h2].forEach((e4) => e4.style.display = i3 ? "none" : "block"), i3 && (K = 1, Yt2.update(i3)), !Se2 || st2 && Yt2.isActive || (i3 ? ((e4, t3, r4) => {
        Et(r4);
        let i4 = e4._gsap;
        if (i4.spacerIsNative)
          Et(i4.spacerState);
        else if (e4._gsap.swappedIn) {
          let r5 = t3.parentNode;
          r5 && (r5.insertBefore(e4, t3), r5.removeChild(t3));
        }
        e4._gsap.swappedIn = false;
      })(Se2, b2, f2) : Tt(Se2, b2, Fe(Se2), R2)), i3 || Yt2.update(i3), K = o3, Yt2.isReverted = i3);
    }, Yt2.refresh = (i3, o3) => {
      if ((K || !Yt2.enabled) && !o3)
        return;
      if (Se2 && i3 && be)
        return void je(Dt, "scrollEnd", pt);
      !ue && It2 && It2(Yt2), K = 1, zt2 = ye(), r2.tween && (r2.tween.kill(), r2.tween = 0), q2 && q2.pause(), Pe2 && t2 && t2.revert({ kill: false }).invalidate(), Yt2.isReverted || Yt2.revert(true, true), Yt2._subPinOffset = false;
      let g3, v2, y2, w2, _3, T3, A3, D3, I3, L3, B3, z2 = Lt2(), H3 = Xt2(), V2 = ct2 ? ct2.duration() : Oe(ft2, gt2), U2 = 0, G2 = 0, j3 = e2.end, Z2 = e2.endTrigger || _e2, $3 = e2.start || (0 !== e2.start && _e2 ? Se2 ? "0 0" : "0 100%" : 0), J2 = Yt2.pinnedContainer = e2.pinnedContainer && C(e2.pinnedContainer), re2 = _e2 && Math.max(0, it.indexOf(Yt2)) || 0, se3 = re2;
      for (; se3--; )
        T3 = it[se3], T3.end || T3.refresh(0, 1) || (K = 1), A3 = T3.pin, !A3 || A3 !== _e2 && A3 !== Se2 || T3.isReverted || (L3 || (L3 = []), L3.unshift(T3), T3.revert(true, true)), T3 !== it[se3] && (re2--, se3--);
      for (De($3) && ($3 = $3(Yt2)), a2 = Ct($3, _e2, z2, gt2, Wt2(), c2, p2, Yt2, H3, Ot2, wt2, V2, ct2) || (Se2 ? -1e-3 : 0), De(j3) && (j3 = j3(Yt2)), Re(j3) && !j3.indexOf("+=") && (~j3.indexOf(" ") ? j3 = (Re($3) ? $3.split(" ")[0] : "") + j3 : (U2 = et(j3.substr(2), z2), j3 = Re($3) ? $3 : a2 + U2, Z2 = _e2)), l2 = Math.max(a2, Ct(j3 || (Z2 ? "100% 0" : V2), Z2, z2, gt2, Wt2() + U2, d2, h2, Yt2, H3, Ot2, wt2, V2, ct2)) || -1e-3, u2 = l2 - a2 || (a2 -= 0.01) && 1e-3, U2 = 0, se3 = re2; se3--; )
        T3 = it[se3], A3 = T3.pin, A3 && T3.start - T3._pinPush <= a2 && !ct2 && T3.end > 0 && (g3 = T3.end - T3.start, (A3 === _e2 && T3.start - T3._pinPush < a2 || A3 === J2) && !Ye($3) && (U2 += g3 * (1 - T3.progress)), A3 === Se2 && (G2 += g3));
      if (a2 += U2, l2 += U2, Yt2._pinPush = G2, c2 && U2 && (g3 = {}, g3[gt2.a] = "+=" + U2, J2 && (g3[gt2.p] = "-=" + Wt2()), X.set([c2, d2], g3)), Se2)
        g3 = Fe(Se2), w2 = gt2 === M, y2 = Wt2(), k2 = parseFloat(S2(gt2.a)) + G2, !V2 && l2 > 1 && (B3 = (xt2 ? W.scrollingElement || F : ft2).style, B3 = { style: B3, value: B3["overflow" + gt2.a.toUpperCase()] }, B3["overflow" + gt2.a.toUpperCase()] = "scroll"), Tt(Se2, b2, g3), x2 = Pt(Se2), v2 = He(Se2, true), D3 = wt2 && O(ft2, w2 ? P : M)(), Ee2 && (R2 = [Ee2 + gt2.os2, u2 + G2 + We], R2.t = b2, se3 = Ee2 === ze ? qe(Se2, gt2) + u2 + G2 : 0, se3 && R2.push(gt2.d, se3 + We), Et(R2), J2 && it.forEach((e3) => {
          e3.pin === J2 && false !== e3.vars.pinSpacing && (e3._subPinOffset = true);
        }), wt2 && Wt2(te2)), wt2 && (_3 = { top: v2.top + (w2 ? y2 - a2 : D3) + We, left: v2.left + (w2 ? D3 : y2 - a2) + We, boxSizing: "border-box", position: "fixed" }, _3.width = _3.maxWidth = Math.ceil(v2.width) + We, _3.height = _3.maxHeight = Math.ceil(v2.height) + We, _3.margin = _3.marginTop = _3.marginRight = _3.marginBottom = _3.marginLeft = "0", _3.padding = g3.padding, _3.paddingTop = g3.paddingTop, _3.paddingRight = g3.paddingRight, _3.paddingBottom = g3.paddingBottom, _3.paddingLeft = g3.paddingLeft, m2 = ((e3, t3, r3) => {
          let i4, o4 = [], s3 = e3.length, n3 = r3 ? 8 : 0;
          for (; n3 < s3; n3 += 2)
            i4 = e3[n3], o4.push(i4, i4 in t3 ? t3[i4] : e3[n3 + 1]);
          return o4.t = e3.t, o4;
        })(f2, _3, st2), ue && Wt2(0)), t2 ? (I3 = t2._initted, ie(1), t2.render(t2.duration(), true, true), E2 = S2(gt2.a) - k2 + u2 + G2, Y2 = Math.abs(u2 - E2) > 1, wt2 && Y2 && m2.splice(m2.length - 2, 2), t2.render(0, true, true), I3 || t2.invalidate(true), t2.parent || t2.totalTime(t2.totalTime()), ie(0)) : E2 = u2, B3 && (B3.value ? B3.style["overflow" + gt2.a.toUpperCase()] = B3.value : B3.style.removeProperty("overflow-" + gt2.a));
      else if (_e2 && Wt2() && !ct2)
        for (v2 = _e2.parentNode; v2 && v2 !== N; )
          v2._pinOffset && (a2 -= v2._pinOffset, l2 -= v2._pinOffset), v2 = v2.parentNode;
      L3 && L3.forEach((e3) => e3.revert(false, true)), Yt2.start = a2, Yt2.end = l2, s2 = n2 = ue ? te2 : Wt2(), ct2 || ue || (s2 < te2 && Wt2(te2), Yt2.scroll.rec = 0), Yt2.revert(false, true), Q2 && (Bt2 = -1, Yt2.isActive && Wt2(a2 + u2 * ee2), Q2.restart(true)), K = 0, t2 && ut2 && (t2._initted || oe2) && t2.progress() !== oe2 && t2.progress(oe2, true).render(t2.time(), true, true), (ee2 !== Yt2.progress || ct2) && (t2 && !ut2 && t2.totalProgress(ee2, true), Yt2.progress = (s2 - a2) / u2 === ee2 ? 0 : ee2), Se2 && Ee2 && (b2._pinOffset = Math.round(Yt2.progress * E2)), ge2 && !ue && ge2(Yt2);
    }, Yt2.getVelocity = () => (Wt2() - n2) / (ye() - G) * 1e3 || 0, Yt2.endAnimation = () => {
      Le(Yt2.callbackAnimation), t2 && (q2 ? q2.progress(1) : t2.paused() ? ut2 || Le(t2, Yt2.direction < 0, 1) : Le(t2, t2.reversed()));
    }, Yt2.labelToScroll = (e3) => t2 && t2.labels && (a2 || Yt2.refresh() || a2) + t2.labels[e3] / t2.duration() * u2 || 0, Yt2.getTrailing = (e3) => {
      let t3 = it.indexOf(Yt2), r3 = Yt2.direction > 0 ? it.slice(0, t3).reverse() : it.slice(t3 + 1);
      return (Re(e3) ? r3.filter((t4) => t4.vars.preventOverlaps === e3) : r3).filter((e4) => Yt2.direction > 0 ? e4.end <= a2 : e4.start >= l2);
    }, Yt2.update = (e3, i3, o3) => {
      if (ct2 && !o3 && !e3)
        return;
      let c3, d3, h3, g3, f3, v2, y2, w2, _3 = ue ? te2 : Yt2.scroll(), S3 = e3 ? 0 : (_3 - a2) / u2, P2 = S3 < 0 ? 0 : S3 > 1 ? 1 : S3 || 0, C2 = Yt2.progress;
      if (i3 && (n2 = s2, s2 = ct2 ? Wt2() : _3, rt2 && (H2 = B2, B2 = t2 && !ut2 ? t2.totalProgress() : P2)), Ae2 && !P2 && Se2 && !K && !ve && be && a2 < _3 + (_3 - n2) / (ye() - G) * Ae2 && (P2 = 1e-4), P2 !== C2 && Yt2.enabled) {
        if (c3 = Yt2.isActive = !!P2 && P2 < 1, d3 = !!C2 && C2 < 1, v2 = c3 !== d3, f3 = v2 || !!P2 != !!C2, Yt2.direction = P2 > C2 ? 1 : -1, Yt2.progress = P2, f3 && !K && (h3 = P2 && !C2 ? 0 : 1 === P2 ? 1 : 1 === C2 ? 2 : 3, ut2 && (g3 = !v2 && "none" !== St2[h3 + 1] && St2[h3 + 1] || St2[h3], w2 = t2 && ("complete" === g3 || "reset" === g3 || g3 in t2))), ht2 && (v2 || w2) && (w2 || xe2 || !t2) && (De(ht2) ? ht2(Yt2) : Yt2.getTrailing(ht2).forEach((e4) => e4.endAnimation())), ut2 || (!q2 || K || ve ? t2 && t2.totalProgress(P2, !!K) : (q2._dp._time - q2._start !== q2._time && q2.render(q2._dp._time - q2._start), q2.resetTo ? q2.resetTo("totalProgress", P2, t2._tTime / t2._tDur) : (q2.vars.totalProgress = P2, q2.invalidate().restart()))), Se2)
          if (e3 && Ee2 && (b2.style[Ee2 + gt2.os2] = A2), wt2) {
            if (f3) {
              if (y2 = !e3 && P2 > C2 && l2 + 1 > _3 && _3 + 1 >= Oe(ft2, gt2), st2)
                if (e3 || !c3 && !y2)
                  At(Se2, b2);
                else {
                  let e4 = He(Se2, true), t3 = _3 - a2;
                  At(Se2, N, e4.top + (gt2 === M ? t3 : 0) + We, e4.left + (gt2 === M ? 0 : t3) + We);
                }
              Et(c3 || y2 ? m2 : x2), Y2 && P2 < 1 && c3 || T2(k2 + (1 !== P2 || y2 ? 0 : E2));
            }
          } else
            T2(ke(k2 + E2 * P2));
        rt2 && !r2.tween && !K && !ve && Q2.restart(true), le2 && (v2 || Qe2 && P2 && (P2 < 1 || !he)) && V(le2.targets).forEach((e4) => e4.classList[c3 || Qe2 ? "add" : "remove"](le2.className)), ae2 && !ut2 && !e3 && ae2(Yt2), f3 && !K ? (ut2 && (w2 && ("complete" === g3 ? t2.pause().totalProgress(1) : "reset" === g3 ? t2.restart(true).pause() : "restart" === g3 ? t2.restart(true) : t2[g3]()), ae2 && ae2(Yt2)), !v2 && he || (pe2 && v2 && Xe(Yt2, pe2), _t2[h3] && Xe(Yt2, _t2[h3]), Qe2 && (1 === P2 ? Yt2.kill(false, 1) : _t2[h3] = 0), v2 || (h3 = 1 === P2 ? 1 : 3, _t2[h3] && Xe(Yt2, _t2[h3]))), dt2 && !c3 && Math.abs(Yt2.getVelocity()) > (Ye(dt2) ? dt2 : 2500) && (Le(Yt2.callbackAnimation), q2 ? q2.progress(1) : Le(t2, "reverse" === g3 ? 1 : !P2, 1))) : ut2 && ae2 && !K && ae2(Yt2);
      }
      if (I2) {
        let e4 = ct2 ? _3 / ct2.duration() * (ct2._caScrollDist || 0) : _3;
        D2(e4 + (p2._isFlipped ? 1 : 0)), I2(e4);
      }
      se2 && se2(-_3 / ct2.duration() * (ct2._caScrollDist || 0));
    }, Yt2.enable = (e3, t3) => {
      Yt2.enabled || (Yt2.enabled = true, je(ft2, "resize", lt), je(xt2 ? W : ft2, "scroll", nt), It2 && je(Dt, "refreshInit", It2), false !== e3 && (Yt2.progress = ee2 = 0, s2 = n2 = Bt2 = Wt2()), false !== t3 && Yt2.refresh());
    }, Yt2.getTween = (e3) => e3 && r2 ? r2.tween : q2, Yt2.setPositions = (e3, t3) => {
      Se2 && (k2 += e3 - a2, E2 += t3 - e3 - u2, Ee2 === ze && Yt2.adjustPinSpacing(t3 - e3 - u2)), Yt2.start = a2 = e3, Yt2.end = l2 = t3, u2 = t3 - e3, Yt2.update();
    }, Yt2.adjustPinSpacing = (e3) => {
      if (R2) {
        let t3 = R2.indexOf(gt2.d) + 1;
        R2[t3] = parseFloat(R2[t3]) + e3 + We, R2[1] = parseFloat(R2[1]) + e3 + We, Et(R2);
      }
    }, Yt2.disable = (e3, t3) => {
      if (Yt2.enabled && (false !== e3 && Yt2.revert(true, true), Yt2.enabled = Yt2.isActive = false, t3 || q2 && q2.pause(), te2 = 0, i2 && (i2.uncache = 1), It2 && Ke(Dt, "refreshInit", It2), Q2 && (Q2.pause(), r2.tween && r2.tween.kill() && (r2.tween = 0)), !xt2)) {
        let e4 = it.length;
        for (; e4--; )
          if (it[e4].scroller === ft2 && it[e4] !== Yt2)
            return;
        Ke(ft2, "resize", lt), Ke(ft2, "scroll", nt);
      }
    }, Yt2.kill = (r3, o3) => {
      Yt2.disable(r3, o3), q2 && !o3 && q2.kill(), ce2 && delete ot[ce2];
      let s3 = it.indexOf(Yt2);
      s3 >= 0 && it.splice(s3, 1), s3 === J && bt > 0 && J--, s3 = 0, it.forEach((e3) => e3.scroller === Yt2.scroller && (s3 = 1)), s3 || ue || (Yt2.scroll.rec = 0), t2 && (t2.scrollTrigger = null, r3 && t2.revert({ kill: false }), o3 || t2.kill()), c2 && [c2, d2, p2, h2].forEach((e3) => e3.parentNode && e3.parentNode.removeChild(e3)), me === Yt2 && (me = 0), Se2 && (i2 && (i2.uncache = 1), s3 = 0, it.forEach((e3) => e3.pin === Se2 && s3++), s3 || (i2.spacer = 0)), e2.onKill && e2.onKill(Yt2);
    }, Yt2.enable(false, false), ne2 && ne2(Yt2), t2 && t2.add && !u2 ? X.delayedCall(0.01, () => a2 || l2 || Yt2.refresh()) && (u2 = 0.01) && (a2 = l2 = 0) : Yt2.refresh(), Se2 && (() => {
      if (fe !== vt) {
        let e3 = fe = vt;
        requestAnimationFrame(() => e3 === vt && yt(true));
      }
    })();
  }
  static register(e2) {
    return B || (X = e2 || Pe(), Ee() && window.document && Dt.enable(), B = we), B;
  }
  static defaults(e2) {
    if (e2)
      for (let t2 in e2)
        Je[t2] = e2[t2];
    return Je;
  }
  static disable(e2, t2) {
    we = 0, it.forEach((r2) => r2[t2 ? "kill" : "disable"](e2)), Ke(z, "wheel", nt), Ke(W, "scroll", nt), clearInterval(j), Ke(W, "touchcancel", Te), Ke(N, "touchstart", Te), Ge(Ke, W, "pointerdown,touchstart,mousedown", _e), Ge(Ke, W, "pointerup,touchend,mouseup", Se), q.kill(), Ae(Ke);
    for (let e3 = 0; e3 < v.length; e3 += 3)
      Ze(Ke, v[e3], v[e3 + 1]), Ze(Ke, v[e3], v[e3 + 2]);
  }
  static enable() {
    if (z = window, W = document, F = W.documentElement, N = W.body, X && (V = X.utils.toArray, U = X.utils.clamp, de = X.core.context || Te, ie = X.core.suppressOverwrites || Te, pe = z.history.scrollRestoration || "auto", X.core.globals("ScrollTrigger", Dt), N)) {
      we = 1, L.register(X), Dt.isTouch = L.isTouch, ce = L.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), je(z, "wheel", nt), H = [z, W, F, N], X.matchMedia ? (Dt.matchMedia = (e3) => {
        let t3, r3 = X.matchMedia();
        for (t3 in e3)
          r3.add(t3, e3[t3]);
        return r3;
      }, X.addEventListener("matchMediaInit", () => ft()), X.addEventListener("matchMediaRevert", () => ut()), X.addEventListener("matchMedia", () => {
        yt(0, 1), ht("matchMedia");
      }), X.matchMedia("(orientation: portrait)", () => (at(), at))) : console.warn("Requires GSAP 3.11.0 or later"), at(), je(W, "scroll", nt);
      let e2, t2, r2 = N.style, i2 = r2.borderTopStyle, o2 = X.core.Animation.prototype;
      for (o2.revert || Object.defineProperty(o2, "revert", { value: function() {
        return this.time(-0.01, true);
      } }), r2.borderTopStyle = "solid", e2 = He(N), M.m = Math.round(e2.top + M.sc()) || 0, P.m = Math.round(e2.left + P.sc()) || 0, i2 ? r2.borderTopStyle = i2 : r2.removeProperty("border-top-style"), j = setInterval(st, 250), X.delayedCall(0.5, () => ve = 0), je(W, "touchcancel", Te), je(N, "touchstart", Te), Ge(je, W, "pointerdown,touchstart,mousedown", _e), Ge(je, W, "pointerup,touchend,mouseup", Se), $ = X.utils.checkPrefix("transform"), St.push($), B = ye(), q = X.delayedCall(0.2, yt).pause(), te = [W, "visibilitychange", () => {
        let e3 = z.innerWidth, t3 = z.innerHeight;
        W.hidden ? (Q = e3, ee = t3) : Q === e3 && ee === t3 || lt();
      }, W, "DOMContentLoaded", yt, z, "load", yt, z, "resize", lt], Ae(je), it.forEach((e3) => e3.enable(0, 1)), t2 = 0; t2 < v.length; t2 += 3)
        Ze(Ke, v[t2], v[t2 + 1]), Ze(Ke, v[t2], v[t2 + 2]);
    }
  }
  static config(e2) {
    "limitCallbacks" in e2 && (he = !!e2.limitCallbacks);
    let t2 = e2.syncInterval;
    t2 && clearInterval(j) || (j = t2) && setInterval(st, t2), "ignoreMobileResize" in e2 && (ne = 1 === Dt.isTouch && e2.ignoreMobileResize), "autoRefreshEvents" in e2 && (Ae(Ke) || Ae(je, e2.autoRefreshEvents || "none"), oe = -1 === (e2.autoRefreshEvents + "").indexOf("resize"));
  }
  static scrollerProxy(e2, t2) {
    let r2 = C(e2), i2 = v.indexOf(r2), o2 = Me(r2);
    ~i2 && v.splice(i2, o2 ? 6 : 2), t2 && (o2 ? y.unshift(z, t2, N, t2, F, t2) : y.unshift(r2, t2));
  }
  static clearMatchMedia(e2) {
    it.forEach((t2) => t2._ctx && t2._ctx.query === e2 && t2._ctx.kill(true, true));
  }
  static isInViewport(e2, t2, r2) {
    let i2 = (Re(e2) ? C(e2) : e2).getBoundingClientRect(), o2 = i2[r2 ? "width" : "height"] * t2 || 0;
    return r2 ? i2.right - o2 > 0 && i2.left + o2 < z.innerWidth : i2.bottom - o2 > 0 && i2.top + o2 < z.innerHeight;
  }
  static positionInViewport(e2, t2, r2) {
    Re(e2) && (e2 = C(e2));
    let i2 = e2.getBoundingClientRect(), o2 = i2[r2 ? "width" : "height"], s2 = null == t2 ? o2 / 2 : t2 in Qe ? Qe[t2] * o2 : ~t2.indexOf("%") ? parseFloat(t2) * o2 / 100 : parseFloat(t2) || 0;
    return r2 ? (i2.left + s2) / z.innerWidth : (i2.top + s2) / z.innerHeight;
  }
  static killAll(e2) {
    if (it.slice(0).forEach((e3) => "ScrollSmoother" !== e3.vars.id && e3.kill()), true !== e2) {
      let e3 = ct.killAll || [];
      ct = {}, e3.forEach((e4) => e4());
    }
  }
};
Dt.version = "3.11.4", Dt.saveStyles = (e2) => e2 ? V(e2).forEach((e3) => {
  if (e3 && e3.style) {
    let t2 = gt.indexOf(e3);
    t2 >= 0 && gt.splice(t2, 5), gt.push(e3, e3.style.cssText, e3.getBBox && e3.getAttribute("transform"), X.core.getCache(e3), de());
  }
}) : gt, Dt.revert = (e2, t2) => ft(!e2, t2), Dt.create = (e2, t2) => new Dt(e2, t2), Dt.refresh = (e2) => e2 ? lt() : (B || Dt.register()) && yt(true), Dt.update = (e2) => ++v.cache && wt(true === e2 ? 2 : 0), Dt.clearScrollMemory = mt, Dt.maxScroll = (e2, t2) => Oe(e2, t2 ? P : M), Dt.getScrollFunc = (e2, t2) => O(C(e2), t2 ? P : M), Dt.getById = (e2) => ot[e2], Dt.getAll = () => it.filter((e2) => "ScrollSmoother" !== e2.vars.id), Dt.isScrolling = () => !!be, Dt.snapDirectional = Ue, Dt.addEventListener = (e2, t2) => {
  let r2 = ct[e2] || (ct[e2] = []);
  ~r2.indexOf(t2) || r2.push(t2);
}, Dt.removeEventListener = (e2, t2) => {
  let r2 = ct[e2], i2 = r2 && r2.indexOf(t2);
  i2 >= 0 && r2.splice(i2, 1);
}, Dt.batch = (e2, t2) => {
  let r2, i2 = [], o2 = {}, s2 = t2.interval || 0.016, n2 = t2.batchMax || 1e9, a2 = (e3, t3) => {
    let r3 = [], i3 = [], o3 = X.delayedCall(s2, () => {
      t3(r3, i3), r3 = [], i3 = [];
    }).pause();
    return (e4) => {
      r3.length || o3.restart(true), r3.push(e4.trigger), i3.push(e4), n2 <= r3.length && o3.progress(1);
    };
  };
  for (r2 in t2)
    o2[r2] = "on" === r2.substr(0, 2) && De(t2[r2]) && "onRefreshInit" !== r2 ? a2(0, t2[r2]) : t2[r2];
  return De(n2) && (n2 = n2(), je(Dt, "refresh", () => n2 = t2.batchMax())), V(e2).forEach((e3) => {
    let t3 = {};
    for (r2 in o2)
      t3[r2] = o2[r2];
    t3.trigger = e3, i2.push(Dt.create(t3));
  }), i2;
};
var Yt;
var It = (e2, t2, r2, i2) => (t2 > i2 ? e2(i2) : t2 < 0 && e2(0), r2 > i2 ? (i2 - t2) / (r2 - t2) : r2 < 0 ? t2 / (t2 - r2) : 1);
var Lt = (e2, t2) => {
  true === t2 ? e2.style.removeProperty("touch-action") : e2.style.touchAction = true === t2 ? "auto" : t2 ? "pan-" + t2 + (L.isTouch ? " pinch-zoom" : "") : "none", e2 === F && Lt(N, t2);
};
var Xt = { auto: 1, scroll: 1 };
var Bt = ({ event: e2, target: t2, axis: r2 }) => {
  let i2, o2 = (e2.changedTouches ? e2.changedTouches[0] : e2).target, s2 = o2._gsap || X.core.getCache(o2), n2 = ye();
  if (!s2._isScrollT || n2 - s2._isScrollT > 2e3) {
    for (; o2 && o2 !== N && (o2.scrollHeight <= o2.clientHeight && o2.scrollWidth <= o2.clientWidth || !Xt[(i2 = Fe(o2)).overflowY] && !Xt[i2.overflowX]); )
      o2 = o2.parentNode;
    s2._isScroll = o2 && o2 !== t2 && !Me(o2) && (Xt[(i2 = Fe(o2)).overflowY] || Xt[i2.overflowX]), s2._isScrollT = n2;
  }
  (s2._isScroll || "x" === r2) && (e2.stopPropagation(), e2._gsapAllow = true);
};
var zt = (e2, t2, r2, i2) => L.create({ target: e2, capture: true, debounce: false, lockAxis: true, type: t2, onWheel: i2 = i2 && Bt, onPress: i2, onDrag: i2, onScroll: i2, onEnable: () => r2 && je(W, L.eventTypes[0], Ft, false, true), onDisable: () => Ke(W, L.eventTypes[0], Ft, true) });
var Wt = /(input|label|select|textarea)/i;
var Ft = (e2) => {
  let t2 = Wt.test(e2.target.tagName);
  (t2 || Yt) && (e2._gsapAllow = true, Yt = t2);
};
var Nt = (e2) => {
  Ie(e2) || (e2 = {}), e2.preventDefault = e2.isNormalizer = e2.allowClicks = true, e2.type || (e2.type = "wheel,touch"), e2.debounce = !!e2.debounce, e2.id = e2.id || "normalizer";
  let t2, r2, i2, o2, s2, n2, a2, l2, { normalizeScrollX: c2, momentum: d2, allowNestedScroll: p2 } = e2, h2 = C(e2.target) || F, g2 = X.core.globals().ScrollSmoother, u2 = g2 && g2.get(), f2 = ce && (e2.content && C(e2.content) || u2 && false !== e2.content && !u2.smooth() && u2.content()), m2 = O(h2, M), y2 = O(h2, P), x2 = 1, b2 = (L.isTouch && z.visualViewport ? z.visualViewport.scale * z.visualViewport.width : z.outerWidth) / z.innerWidth, w2 = 0, _2 = De(d2) ? () => d2(t2) : () => d2 || 2.8, S2 = zt(h2, e2.type, true, p2), T2 = () => o2 = false, k2 = Te, E2 = Te, A2 = () => {
    r2 = Oe(h2, M), E2 = U(ce ? 1 : 0, r2), c2 && (k2 = U(0, Oe(h2, P))), i2 = vt;
  }, R2 = () => {
    f2._gsap.y = ke(parseFloat(f2._gsap.y) + m2.offset) + "px", f2.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(f2._gsap.y) + ", 0, 1)", m2.offset = m2.cacheID = 0;
  }, D2 = () => {
    A2(), s2.isActive() && s2.vars.scrollY > r2 && (m2() > r2 ? s2.progress(1) && m2(r2) : s2.resetTo("scrollY", r2));
  };
  return f2 && X.set(f2, { y: "+=0" }), e2.ignoreCheck = (e3) => ce && "touchmove" === e3.type && (() => {
    if (o2) {
      requestAnimationFrame(T2);
      let e4 = ke(t2.deltaY / 2), r3 = E2(m2.v - e4);
      if (f2 && r3 !== m2.v + m2.offset) {
        m2.offset = r3 - m2.v;
        let e5 = ke((parseFloat(f2 && f2._gsap.y) || 0) - m2.offset);
        f2.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + e5 + ", 0, 1)", f2._gsap.y = e5 + "px", m2.cacheID = v.cache, wt();
      }
      return true;
    }
    m2.offset && R2(), o2 = true;
  })() || x2 > 1.05 && "touchstart" !== e3.type || t2.isGesturing || e3.touches && e3.touches.length > 1, e2.onPress = () => {
    let e3 = x2;
    x2 = ke((z.visualViewport && z.visualViewport.scale || 1) / b2), s2.pause(), e3 !== x2 && Lt(h2, x2 > 1.01 || !c2 && "x"), n2 = y2(), a2 = m2(), A2(), i2 = vt;
  }, e2.onRelease = e2.onGestureStart = (e3, t3) => {
    if (m2.offset && R2(), t3) {
      v.cache++;
      let t4, i3, o3 = _2();
      c2 && (t4 = y2(), i3 = t4 + 0.05 * o3 * -e3.velocityX / 0.227, o3 *= It(y2, t4, i3, Oe(h2, P)), s2.vars.scrollX = k2(i3)), t4 = m2(), i3 = t4 + 0.05 * o3 * -e3.velocityY / 0.227, o3 *= It(m2, t4, i3, Oe(h2, M)), s2.vars.scrollY = E2(i3), s2.invalidate().duration(o3).play(0.01), (ce && s2.vars.scrollY >= r2 || t4 >= r2 - 1) && X.to({}, { onUpdate: D2, duration: o3 });
    } else
      l2.restart(true);
  }, e2.onWheel = () => {
    s2._ts && s2.pause(), ye() - w2 > 1e3 && (i2 = 0, w2 = ye());
  }, e2.onChange = (e3, t3, r3, o3, s3) => {
    if (vt !== i2 && A2(), t3 && c2 && y2(k2(o3[2] === t3 ? n2 + (e3.startX - e3.x) : y2() + t3 - o3[1])), r3) {
      m2.offset && R2();
      let t4 = s3[2] === r3, i3 = t4 ? a2 + e3.startY - e3.y : m2() + r3 - s3[1], o4 = E2(i3);
      t4 && i3 !== o4 && (a2 += o4 - i3), m2(o4);
    }
    (r3 || t3) && wt();
  }, e2.onEnable = () => {
    Lt(h2, !c2 && "x"), Dt.addEventListener("refresh", D2), je(z, "resize", D2), m2.smooth && (m2.target.style.scrollBehavior = "auto", m2.smooth = y2.smooth = false), S2.enable();
  }, e2.onDisable = () => {
    Lt(h2, true), Ke(z, "resize", D2), Dt.removeEventListener("refresh", D2), S2.kill();
  }, e2.lockAxis = false !== e2.lockAxis, t2 = new L(e2), t2.iOS = ce, ce && !m2() && m2(1), ce && X.ticker.add(Te), l2 = t2._dc, s2 = X.to(t2, { ease: "power4", paused: true, scrollX: c2 ? "+=0.1" : "+=0", scrollY: "+=0.1", onComplete: l2.vars.onComplete }), t2;
};
Dt.sort = (e2) => it.sort(e2 || ((e3, t2) => -1e6 * (e3.vars.refreshPriority || 0) + e3.start - (t2.start + -1e6 * (t2.vars.refreshPriority || 0)))), Dt.observe = (e2) => new L(e2), Dt.normalizeScroll = (e2) => {
  if (void 0 === e2)
    return se;
  if (true === e2 && se)
    return se.enable();
  if (false === e2)
    return se && se.kill();
  let t2 = e2 instanceof L ? e2 : Nt(e2);
  return se && se.target === t2.target && se.kill(), Me(t2.target) && (se = t2), t2;
}, Dt.core = { _getVelocityProp: A, _inputObserver: zt, _scrollers: v, _proxies: y, bridge: { ss: () => {
  be || ht("scrollStart"), be = ye();
}, ref: () => K } }, Pe() && X.registerPlugin(Dt);
var ScrollTrigger_default = Dt;
export {
  Dt as ScrollTrigger,
  ScrollTrigger_default as default
};
/*! Bundled license information:

gsap-trial/ScrollTrigger.js:
  (*!
   * ScrollTrigger 3.11.4
   * https://greensock.com
   * 
   * @license Copyright 2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
   *)
*/
//# sourceMappingURL=gsap-trial_ScrollTrigger.js.map
