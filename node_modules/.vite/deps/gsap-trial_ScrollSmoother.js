import "./chunk-DSTXS4JB.js";

// node_modules/gsap-trial/ScrollSmoother.js
var e;
var t;
var r;
var o;
var n;
var s;
var i;
var a;
var l;
var c;
var d;
var h;
var g;
var f;
var p;
var u = () => "undefined" != typeof window;
var m = () => e || u() && (e = window.gsap) && e.registerPlugin && e;
var v = function() {
  return String.fromCharCode.apply(null, arguments);
};
var y = v(103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109);
var w = (function(e2) {
  var t2 = "undefined" != typeof window, r2 = 0 === (t2 ? window.location.href : "").indexOf(v(102, 105, 108, 101, 58, 47, 47)) || -1 !== e2.indexOf(v(108, 111, 99, 97, 108, 104, 111, 115, 116)) || -1 !== e2.indexOf(v(49, 50, 55, 46, 48, 32, 48, 46, 49)), o2 = [y, v(99, 111, 100, 101, 112, 101, 110, 46, 105, 111), v(99, 111, 100, 101, 112, 101, 110, 46, 112, 108, 117, 109, 98, 105, 110, 103), v(99, 111, 100, 101, 112, 101, 110, 46, 100, 101, 118), v(99, 111, 100, 101, 112, 101, 110, 46, 97, 112, 112), v(99, 111, 100, 101, 112, 101, 110, 46, 119, 101, 98, 115, 105, 116, 101), v(112, 101, 110, 115, 46, 99, 108, 111, 117, 100), v(99, 115, 115, 45, 116, 114, 105, 99, 107, 115, 46, 99, 111, 109), v(99, 100, 112, 110, 46, 105, 111), v(112, 101, 110, 115, 46, 105, 111), v(103, 97, 110, 110, 111, 110, 46, 116, 118), v(99, 111, 100, 101, 99, 97, 110, 121, 111, 110, 46, 110, 101, 116), v(116, 104, 101, 109, 101, 102, 111, 114, 101, 115, 116, 46, 110, 101, 116), v(99, 101, 114, 101, 98, 114, 97, 120, 46, 99, 111, 46, 117, 107), v(116, 121, 109, 112, 97, 110, 117, 115, 46, 110, 101, 116), v(116, 119, 101, 101, 110, 109, 97, 120, 46, 99, 111, 109), v(112, 108, 110, 107, 114, 46, 99, 111), v(104, 111, 116, 106, 97, 114, 46, 99, 111, 109), v(119, 101, 98, 112, 97, 99, 107, 98, 105, 110, 46, 99, 111, 109), v(97, 114, 99, 104, 105, 118, 101, 46, 111, 114, 103), v(99, 111, 100, 101, 115, 97, 110, 100, 98, 111, 120, 46, 105, 111), v(99, 115, 98, 46, 97, 112, 112), v(115, 116, 97, 99, 107, 98, 108, 105, 116, 122, 46, 99, 111, 109), v(115, 116, 97, 99, 107, 98, 108, 105, 116, 122, 46, 105, 111), v(99, 111, 100, 105, 101, 114, 46, 105, 111), v(109, 111, 116, 105, 111, 110, 116, 114, 105, 99, 107, 115, 46, 99, 111, 109), v(115, 116, 97, 99, 107, 111, 118, 101, 114, 102, 108, 111, 119, 46, 99, 111, 109), v(115, 116, 97, 99, 107, 101, 120, 99, 104, 97, 110, 103, 101, 46, 99, 111, 109), v(115, 116, 117, 100, 105, 111, 102, 114, 101, 105, 103, 104, 116, 46, 99, 111, 109), v(119, 101, 98, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 105, 111), v(106, 115, 102, 105, 100, 100, 108, 101, 46, 110, 101, 116)], n2 = function() {
    t2 && ("loading" === document.readyState || "interactive" === document.readyState ? document.addEventListener("readystatechange", n2) : (document.removeEventListener("readystatechange", n2), t2 && window.console && !window._gsapWarned && "object" == typeof window.gsap && false !== window.gsap.config().trialWarn && (console.log(v(37, 99, 87, 97, 114, 110, 105, 110, 103), v(102, 111, 110, 116, 45, 115, 105, 122, 101, 58, 51, 48, 112, 120, 59, 99, 111, 108, 111, 114, 58, 114, 101, 100, 59)), console.log(v(65, 32, 116, 114, 105, 97, 108, 32, 118, 101, 114, 115, 105, 111, 110, 32, 111, 102, 32) + "ScrollSmoother" + v(32, 105, 115, 32, 108, 111, 97, 100, 101, 100, 32, 116, 104, 97, 116, 32, 111, 110, 108, 121, 32, 119, 111, 114, 107, 115, 32, 108, 111, 99, 97, 108, 108, 121, 32, 97, 110, 100, 32, 111, 110, 32, 100, 111, 109, 97, 105, 110, 115, 32, 108, 105, 107, 101, 32, 99, 111, 100, 101, 112, 101, 110, 46, 105, 111, 32, 97, 110, 100, 32, 99, 111, 100, 101, 115, 97, 110, 100, 98, 111, 120, 46, 105, 111, 46, 32, 42, 42, 42, 32, 68, 79, 32, 78, 79, 84, 32, 68, 69, 80, 76, 79, 89, 32, 84, 72, 73, 83, 32, 70, 73, 76, 69, 32, 42, 42, 42, 32, 76, 111, 97, 100, 105, 110, 103, 32, 105, 116, 32, 111, 110, 32, 97, 110, 32, 117, 110, 97, 117, 116, 104, 111, 114, 105, 122, 101, 100, 32, 115, 105, 116, 101, 32, 118, 105, 111, 108, 97, 116, 101, 115, 32, 116, 104, 101, 32, 108, 105, 99, 101, 110, 115, 101, 32, 97, 110, 100, 32, 119, 105, 108, 108, 32, 99, 97, 117, 115, 101, 32, 97, 32, 114, 101, 100, 105, 114, 101, 99, 116, 46, 32, 80, 108, 101, 97, 115, 101, 32, 106, 111, 105, 110, 32, 67, 108, 117, 98, 32, 71, 114, 101, 101, 110, 83, 111, 99, 107, 32, 116, 111, 32, 103, 101, 116, 32, 102, 117, 108, 108, 32, 97, 99, 99, 101, 115, 115, 32, 116, 111, 32, 116, 104, 101, 32, 98, 111, 110, 117, 115, 32, 112, 108, 117, 103, 105, 110, 115, 32, 116, 104, 97, 116, 32, 98, 111, 111, 115, 116, 32, 121, 111, 117, 114, 32, 97, 110, 105, 109, 97, 116, 105, 111, 110, 32, 115, 117, 112, 101, 114, 112, 111, 119, 101, 114, 115, 46, 32, 68, 105, 115, 97, 98, 108, 101, 32, 116, 104, 105, 115, 32, 119, 97, 114, 110, 105, 110, 103, 32, 119, 105, 116, 104, 32, 103, 115, 97, 112, 46, 99, 111, 110, 102, 105, 103, 40, 123, 116, 114, 105, 97, 108, 87, 97, 114, 110, 58, 32, 102, 97, 108, 115, 101, 125, 41, 59)), console.log(v(37, 99, 71, 101, 116, 32, 117, 110, 114, 101, 115, 116, 114, 105, 99, 116, 101, 100, 32, 102, 105, 108, 101, 115, 32, 97, 116, 32, 104, 116, 116, 112, 115, 58, 47, 47, 103, 114, 101, 101, 110, 115, 111, 99, 107, 46, 99, 111, 109, 47, 99, 108, 117, 98), v(102, 111, 110, 116, 45, 115, 105, 122, 101, 58, 49, 54, 112, 120, 59, 99, 111, 108, 111, 114, 58, 35, 52, 101, 57, 56, 49, 53)), window._gsapWarned = 1)));
  }, s2 = o2.length;
  for (setTimeout(n2, 50); --s2 > -1; )
    if (-1 !== e2.indexOf(o2[s2]))
      return true;
  r2 || setTimeout(function() {
    t2 && (window.location.href = v(104, 116, 116, 112, 115, 58, 47, 47) + y + v(47, 114, 101, 113, 117, 105, 114, 101, 115, 45, 109, 101, 109, 98, 101, 114, 115, 104, 105, 112, 47) + "?plugin=ScrollSmoother&source=trial");
  }, 3e3);
}("undefined" != typeof window ? window.location.host : ""), (e2) => {
  let t2 = o.querySelector(".ScrollSmoother-wrapper");
  return t2 || (t2 = o.createElement("div"), t2.classList.add("ScrollSmoother-wrapper"), e2.parentNode.insertBefore(t2, e2), t2.appendChild(e2)), t2;
});
var S = class {
  constructor(u2) {
    t || S.register(e) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"), u2 = this.vars = u2 || {}, c && c.kill(), c = this, f(this);
    let m2, v2, y2, b, T, x, E, P, k, R, C, _, A, z, M, { smoothTouch: F, onUpdate: L, onStop: O, smooth: B, onFocusIn: H, normalizeScroll: I, wholePixels: N } = u2, U = this, q = "undefined" != typeof ResizeObserver && false !== u2.autoResize && new ResizeObserver(() => l.isRefreshing || p.restart(true)), V = u2.effectsPrefix || "", W = l.getScrollFunc(r), D = 1 === l.isTouch ? true === F ? 0.8 : parseFloat(F) || 0 : 0 === B || false === B ? 0 : parseFloat(B) || 0.8, Y = D && +u2.speed || 1, j = 0, K = 0, G = 1, J = h(0), Q = () => J.update(-j), X = { y: 0 }, Z = () => m2.style.overflow = "visible", $ = (e2) => {
      e2.update();
      let t2 = e2.getTween();
      t2 && (t2.pause(), t2._time = t2._dur, t2._tTime = t2._tDur), z = false, e2.animation.progress(e2.progress, true);
    }, ee = (e2, t2) => {
      (e2 !== j && !R || t2) && (N && (e2 = Math.round(e2)), D && (m2.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + e2 + ", 0, 1)", m2._gsap.y = e2 + "px"), K = e2 - j, j = e2, l.isUpdating || l.update());
    }, te = function(e2) {
      return arguments.length ? (e2 < 0 && (e2 = 0), X.y = -e2, z = true, R ? j = -e2 : ee(-e2), l.isRefreshing ? b.update() : W(e2), this) : -j;
    }, re = (e2) => {
      v2.scrollTop = 0, e2.target.contains && e2.target.contains(v2) || H && false === H(this, e2) || (l.isInViewport(e2.target) || e2.target === M || this.scrollTo(e2.target, false, "center center"), M = e2.target);
    }, oe = (t2, r2) => {
      let o2, n2, s2, i2;
      T.forEach((r3) => {
        o2 = r3.pins, i2 = r3.markers, t2.forEach((t3) => {
          r3.trigger && t3.trigger && r3 !== t3 && (t3.trigger === r3.trigger || t3.pinnedContainer === r3.trigger || r3.trigger.contains(t3.trigger)) && (n2 = t3.start, s2 = (n2 - r3.start - r3.offset) / r3.ratio - (n2 - r3.start), o2.forEach((e2) => s2 -= e2.distance / r3.ratio - e2.distance), t3.setPositions(n2 + s2, t3.end + s2), t3.markerStart && i2.push(e.quickSetter([t3.markerStart, t3.markerEnd], "y", "px")), t3.pin && t3.end > 0 && (s2 = t3.end - t3.start, o2.push({ start: t3.start, end: t3.end, distance: s2, trig: t3 }), r3.setPositions(r3.start, r3.end + s2), r3.vars.onRefresh(r3)));
        });
      });
    }, ne = () => {
      Z(), requestAnimationFrame(Z), T && (T.forEach((e2) => {
        let t2 = e2.start, r2 = e2.auto ? Math.min(l.maxScroll(e2.scroller), e2.end) : t2 + (e2.end - t2) / e2.ratio, o2 = (r2 - e2.end) / 2;
        t2 -= o2, r2 -= o2, e2.offset = o2 || 1e-4, e2.pins.length = 0, e2.setPositions(Math.min(t2, r2), Math.max(t2, r2)), e2.vars.onRefresh(e2);
      }), oe(l.sort())), J.reset();
    }, se = () => l.addEventListener("refresh", ne), ie = () => T && T.forEach((e2) => e2.vars.onRefresh(e2)), ae = () => (T && T.forEach((e2) => e2.vars.onRefreshInit(e2)), ie), le = (e2, t2, r2, o2) => () => {
      let n2 = "function" == typeof t2 ? t2(r2, o2) : t2;
      return n2 || 0 === n2 || (n2 = o2.getAttribute("data-" + V + e2) || ("speed" === e2 ? 1 : 0)), o2.setAttribute("data-" + V + e2, n2), "auto" === n2 ? n2 : parseFloat(n2);
    }, ce = (t2, o2, s2, i2, c2) => {
      c2 = ("function" == typeof c2 ? c2(i2, t2) : c2) || 0;
      let h2, g2, f2, p2, u3, m3, y3 = le("speed", o2, i2, t2), w2 = le("lag", s2, i2, t2), S2 = e.getProperty(t2, "y"), b2 = t2._gsap, x2 = () => {
        o2 = y3(), s2 = w2(), h2 = parseFloat(o2) || 1, f2 = "auto" === o2, u3 = f2 ? 0 : 0.5, p2 && p2.kill(), p2 = s2 && e.to(t2, { ease: d, overwrite: false, y: "+=0", duration: s2 }), g2 && (g2.ratio = h2, g2.autoSpeed = f2);
      }, E2 = () => {
        b2.y = S2 + "px", b2.renderTransform(1), x2();
      }, P2 = [], k2 = [], R2 = 0, C2 = (e2) => {
        if (f2) {
          E2();
          let o3 = ((e3, t3) => {
            let o4, s3, i3 = e3.parentNode || n, a2 = e3.getBoundingClientRect(), l2 = i3.getBoundingClientRect(), c3 = l2.top - a2.top, d2 = l2.bottom - a2.bottom, h3 = (Math.abs(c3) > Math.abs(d2) ? c3 : d2) / (1 - t3), g3 = -h3 * t3;
            return h3 > 0 && (o4 = l2.height / (r.innerHeight + l2.height), s3 = 0.5 === o4 ? 2 * l2.height : 2 * Math.min(l2.height, -h3 * o4 / (2 * o4 - 1)) * (t3 || 1), g3 += t3 ? -s3 * t3 : -s3 / 2, h3 += s3), { change: h3, offset: g3 };
          })(t2, a(0, 1, -e2.start / (e2.end - e2.start)));
          R2 = o3.change, m3 = o3.offset;
        } else
          R2 = (e2.end - e2.start) * (1 - h2), m3 = 0;
        P2.forEach((e3) => R2 -= e3.distance * (1 - h2)), e2.vars.onUpdate(e2), p2 && p2.progress(1);
      };
      return x2(), (1 !== h2 || f2 || p2) && (g2 = l.create({ trigger: f2 ? t2.parentNode : t2, start: "top bottom+=" + c2, end: "bottom top-=" + c2, scroller: v2, scrub: true, refreshPriority: -999, onRefreshInit: E2, onRefresh: C2, onKill: (e2) => {
        let t3 = T.indexOf(e2);
        t3 >= 0 && T.splice(t3, 1), E2();
      }, onUpdate: (t3) => {
        let r2, o3, n2, s3 = S2 + R2 * (t3.progress - u3), i3 = P2.length, a2 = 0;
        if (t3.offset) {
          if (i3) {
            for (o3 = -j, n2 = t3.end; i3--; ) {
              if (r2 = P2[i3], r2.trig.isActive || o3 >= r2.start && o3 <= r2.end)
                return void (p2 && (r2.trig.progress += r2.trig.direction < 0 ? 1e-3 : -1e-3, r2.trig.update(0, 0, 1), p2.resetTo("y", parseFloat(b2.y), -K, true), G && p2.progress(1)));
              o3 > r2.end && (a2 += r2.distance), n2 -= r2.distance;
            }
            s3 = S2 + a2 + R2 * ((e.utils.clamp(t3.start, t3.end, o3) - t3.start - a2) / (n2 - t3.start) - u3);
          }
          l2 = s3 + m3, s3 = Math.round(1e5 * l2) / 1e5 || 0, k2.length && !f2 && k2.forEach((e2) => e2(s3 - a2)), p2 ? (p2.resetTo("y", s3, -K, true), G && p2.progress(1)) : (b2.y = s3 + "px", b2.renderTransform(1));
        }
        var l2;
      } }), C2(g2), e.core.getCache(g2.trigger).stRevert = ae, g2.startY = S2, g2.pins = P2, g2.markers = k2, g2.ratio = h2, g2.autoSpeed = f2, t2.style.willChange = "transform"), g2;
    };
    function de() {
      return y2 = m2.clientHeight, m2.style.overflow = "visible", s.style.height = r.innerHeight + (y2 - r.innerHeight) / Y + "px", y2 - r.innerHeight;
    }
    se(), l.addEventListener("killAll", se), e.delayedCall(0.5, () => G = 0), this.scrollTop = te, this.scrollTo = (t2, o2, n2) => {
      let s2 = e.utils.clamp(0, l.maxScroll(r), isNaN(t2) ? this.offset(t2, n2) : +t2);
      o2 ? R ? e.to(this, { duration: D, scrollTop: s2, overwrite: "auto", ease: d }) : W(s2) : te(s2);
    }, this.offset = (t2, r2) => {
      let o2, n2 = (t2 = i(t2)[0]).style.cssText, s2 = l.create({ trigger: t2, start: r2 || "top top" });
      return T && oe([s2]), o2 = s2.start, s2.kill(false), t2.style.cssText = n2, e.core.getCache(t2).uncache = 1, o2;
    }, this.content = function(t2) {
      if (arguments.length) {
        let r2 = i(t2 || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || s.children[0];
        return r2 !== m2 && (m2 = r2, k = m2.getAttribute("style") || "", q && q.observe(m2), e.set(m2, { overflow: "visible", width: "100%", boxSizing: "border-box", y: "+=0" }), D || e.set(m2, { clearProps: "transform" })), this;
      }
      return m2;
    }, this.wrapper = function(t2) {
      return arguments.length ? (v2 = i(t2 || "#smooth-wrapper")[0] || w(m2), P = v2.getAttribute("style") || "", de(), e.set(v2, D ? { overflow: "hidden", position: "fixed", height: "100%", width: "100%", top: 0, left: 0, right: 0, bottom: 0 } : { overflow: "visible", position: "relative", width: "100%", height: "auto", top: "auto", bottom: "auto", left: "auto", right: "auto" }), this) : v2;
    }, this.effects = (e2, t2) => {
      if (T || (T = []), !e2)
        return T.slice(0);
      (e2 = i(e2)).forEach((e3) => {
        let t3 = T.length;
        for (; t3--; )
          T[t3].trigger === e3 && T[t3].kill();
      }), t2 = t2 || {};
      let r2, o2, { speed: n2, lag: s2, effectsPadding: a2 } = t2, l2 = [];
      for (r2 = 0; r2 < e2.length; r2++)
        o2 = ce(e2[r2], n2, s2, r2, a2), o2 && l2.push(o2);
      return T.push(...l2), l2;
    }, this.sections = (e2, t2) => {
      if (x || (x = []), !e2)
        return x.slice(0);
      let r2 = i(e2).map((e3) => l.create({ trigger: e3, start: "top 120%", end: "bottom -20%", onToggle: (t3) => {
        e3.style.opacity = t3.isActive ? "1" : "0", e3.style.pointerEvents = t3.isActive ? "all" : "none";
      } }));
      return t2 && t2.add ? x.push(...r2) : x = r2.slice(0), r2;
    }, this.content(u2.content), this.wrapper(u2.wrapper), this.render = (e2) => ee(e2 || 0 === e2 ? e2 : j), this.getVelocity = () => J.getVelocity(-j), l.scrollerProxy(v2, { scrollTop: te, scrollHeight: () => de() && s.scrollHeight, fixedMarkers: false !== u2.fixedMarkers && !!D, content: m2, getBoundingClientRect: () => ({ top: 0, left: 0, width: r.innerWidth, height: r.innerHeight }) }), l.defaults({ scroller: v2 });
    let he = l.getAll().filter((e2) => e2.scroller === r || e2.scroller === v2);
    he.forEach((e2) => e2.revert(true, true)), b = l.create({ animation: e.fromTo(X, { y: 0 }, { y: () => -de(), immediateRender: false, ease: "none", data: "ScrollSmoother", duration: 100, onUpdate: function() {
      if (this._dur) {
        let e2 = z;
        e2 && ($(b), X.y = j), ee(X.y, e2), Q(), L && !R && L(U);
      }
    } }), onRefreshInit: (e2) => {
      if (T) {
        let e3 = l.getAll().filter((e4) => !!e4.pin);
        T.forEach((t3) => {
          t3.vars.pinnedContainer || e3.forEach((e4) => {
            if (e4.pin.contains(t3.trigger)) {
              let r2 = t3.vars;
              r2.pinnedContainer = e4.pin, t3.vars = null, t3.init(r2, t3.animation);
            }
          });
        });
      }
      let t2 = e2.getTween();
      A = t2 && t2._end > t2._dp._time, _ = j, X.y = 0, D && (v2.style.pointerEvents = "none", v2.scrollTop = 0, setTimeout(() => v2.style.removeProperty("pointer-events"), 50));
    }, onRefresh: (t2) => {
      t2.animation.invalidate(), t2.setPositions(t2.start, de() / Y), A || $(t2), X.y = -W(), ee(X.y), G || t2.animation.progress(e.utils.clamp(0, 1, _ / -t2.end)), A && (t2.progress -= 1e-3, t2.update());
    }, id: "ScrollSmoother", scroller: r, invalidateOnRefresh: true, start: 0, refreshPriority: -9999, end: () => de() / Y, onScrubComplete: () => {
      J.reset(), O && O(this);
    }, scrub: D || true }), this.smooth = function(e2) {
      return arguments.length && (D = e2 || 0, Y = D && +u2.speed || 1, b.scrubDuration(e2)), b.getTween() ? b.getTween().duration() : 0;
    }, b.getTween() && (b.getTween().vars.ease = u2.ease || d), this.scrollTrigger = b, u2.effects && this.effects(true === u2.effects ? "[data-" + V + "speed], [data-" + V + "lag]" : u2.effects, { effectsPadding: u2.effectsPadding }), u2.sections && this.sections(true === u2.sections ? "[data-section]" : u2.sections), he.forEach((e2) => {
      e2.vars.scroller = v2, e2.revert(false, true), e2.init(e2.vars, e2.animation);
    }), this.paused = function(e2, t2) {
      return arguments.length ? (!!R !== e2 && (e2 ? (b.getTween() && b.getTween().pause(), W(-j), J.reset(), C = l.normalizeScroll(), C && C.disable(), R = l.observe({ preventDefault: true, type: "wheel,touch,scroll", debounce: false, allowClicks: true, onChangeY: () => te(-j) }), R.nested = g(n, "wheel,touch,scroll", true, false !== t2)) : (R.nested.kill(), R.kill(), R = 0, C && C.enable(), b.progress = (-j - b.start) / (b.end - b.start), $(b))), this) : !!R;
    }, this.kill = this.revert = () => {
      this.paused(false), $(b), b.kill();
      let e2 = (T || []).concat(x || []), t2 = e2.length;
      for (; t2--; )
        e2[t2].kill();
      l.scrollerProxy(v2), l.removeEventListener("killAll", se), l.removeEventListener("refresh", ne), v2.style.cssText = P, m2.style.cssText = k;
      let o2 = l.defaults({});
      o2 && o2.scroller === v2 && l.defaults({ scroller: r }), this.normalizer && l.normalizeScroll(false), clearInterval(E), c = null, q && q.disconnect(), s.style.removeProperty("height"), r.removeEventListener("focusin", re);
    }, this.refresh = (e2, t2) => b.refresh(e2, t2), I && (this.normalizer = l.normalizeScroll(true === I ? { debounce: true, content: !D && m2 } : I)), l.config(u2), "overscrollBehavior" in r.getComputedStyle(s) && e.set([s, n], { overscrollBehavior: "none" }), "scrollBehavior" in r.getComputedStyle(s) && e.set([s, n], { scrollBehavior: "auto" }), r.addEventListener("focusin", re), E = setInterval(Q, 250), "loading" === o.readyState || requestAnimationFrame(() => l.refresh());
  }
  get progress() {
    return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0;
  }
  static register(v2) {
    return t || (e = v2 || m(), u() && window.document && (r = window, o = document, n = o.documentElement, s = o.body), e && (i = e.utils.toArray, a = e.utils.clamp, d = e.parseEase("expo"), f = e.core.context || function() {
    }, p = e.delayedCall(0.2, () => l.isRefreshing || c && c.refresh()).pause(), l = e.core.globals().ScrollTrigger, e.core.globals("ScrollSmoother", S), s && l && (h = l.core._getVelocityProp, g = l.core._inputObserver, S.refresh = l.refresh, t = 1))), t;
  }
};
S.version = "3.11.4", S.create = (e2) => c && e2 && c.content() === i(e2.content)[0] ? c : new S(e2), S.get = () => c, m() && e.registerPlugin(S);
var ScrollSmoother_default = S;
export {
  S as ScrollSmoother,
  ScrollSmoother_default as default
};
/*! Bundled license information:

gsap-trial/ScrollSmoother.js:
  (*!
   * ScrollSmoother 3.11.4
   * https://greensock.com
   * 
   * @license Copyright 2022, GreenSock. All rights reserved.
   * *** DO NOT DEPLOY THIS FILE ***
   * This is a trial version that only works locally and on domains like codepen.io and codesandbox.io.
   * Loading it on an unauthorized domain violates the license and will cause a redirect.
   * Get the unrestricted file by joining Club GreenSock at https://greensock.com/club
   * @author: Jack Doyle, jack@greensock.com
   *)
*/
//# sourceMappingURL=gsap-trial_ScrollSmoother.js.map
